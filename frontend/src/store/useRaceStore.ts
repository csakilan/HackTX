import { create } from 'zustand';

export interface Driver {
  position: number;
  name: string;
  team: string;
  gap: string;
  interval: string;
  lastLap: string;
  currentLap?: number; // Current lap number
  teamColor: string;
  lapTimes: number[];
}

export interface Message {
  id: string;
  sender: 'driver' | 'ai' | 'engineer';
  text: string;
  timestamp: string;
  confidence?: number;
  severity?: 'high' | 'medium' | 'low';
  createdAt?: number; // Timestamp when message was created (for countdown)
  deliveryTime?: number; // Timestamp when message should be delivered
  isOverride?: boolean; // Whether this was an override message
}

export interface Recommendation {
  id: string;
  type: string;
  text: string;
  confidence: number;
  timestamp: string;
}

export interface TelemetryData {
  lap: number;
  distance: number;
  fuelRemaining: number;
  throttle: number;
  brakePressure: number;
  tireTemps: {
    frontLeft: number;
    frontRight: number;
    rearLeft: number;
    rearRight: number;
  };
  brakeTemps: {
    frontLeft: number;
    frontRight: number;
    rearLeft: number;
    rearRight: number;
  };
}

interface RaceStore {
  drivers: Driver[];
  messages: Message[];
  recommendations: Recommendation[];
  isTranscribing: boolean;
  currentTranscription: string;
  waveformData: number[];
  telemetryData: TelemetryData[];
  fuelData: { lap: number; fuel: number }[];
  currentLap: number;
  
  setDrivers: (drivers: Driver[]) => void;
  setIsTranscribing: (value: boolean) => void;
  setCurrentTranscription: (text: string) => void;
  addMessage: (message: Omit<Message, 'id' | 'timestamp'>) => void;
  addRecommendation: (recommendation: Omit<Recommendation, 'id' | 'timestamp'>) => void;
  updateWaveform: () => void;
  sendMessage: (messageId: string) => void;
  sendRecommendation: (recId: string) => void;
  updateTelemetry: (telemetry: CarlosTelemetry) => void;
  updateFuelData: (lap: number, fuel: number) => void;
}

interface CarlosTelemetry {
  name: string;
  team: string;
  speedKph: number;
  throttlePct: number;
  brakePct: number;
  brakeTempC: number;
  tireTempC: number;
  fuelRemainingL: number;
  currentLap: number;
  pitLap: number;
  inPit: boolean;
  trackMeters: number;
}

const mockDrivers: Driver[] = [
  { position: 1, name: 'M. VERSTAPPEN', team: 'Red Bull Racing', gap: 'LEADER', interval: '-', lastLap: '1:32.145', teamColor: '#3671C6', lapTimes: [92.5, 92.3, 92.1, 92.0, 91.8] },
  { position: 2, name: 'L. HAMILTON', team: 'Mercedes', gap: '+3.521', interval: '+3.521', lastLap: '1:32.389', teamColor: '#27F4D2', lapTimes: [92.8, 92.6, 92.4, 92.3, 92.2] },
  { position: 3, name: 'C. LECLERC', team: 'Ferrari', gap: '+5.892', interval: '+2.371', lastLap: '1:32.567', teamColor: '#E8002D', lapTimes: [93.0, 92.9, 92.7, 92.5, 92.4] },
  { position: 4, name: 'L. NORRIS', team: 'McLaren', gap: '+8.234', interval: '+2.342', lastLap: '1:32.701', teamColor: '#FF8000', lapTimes: [93.2, 93.0, 92.8, 92.7, 92.5] },
  { position: 5, name: 'C. SAINZ', team: 'Ferrari', gap: '+10.567', interval: '+2.333', lastLap: '1:32.834', teamColor: '#E8002D', lapTimes: [93.4, 93.2, 93.0, 92.9, 92.7] },
  { position: 6, name: 'S. PEREZ', team: 'Red Bull Racing', gap: '+12.123', interval: '+1.556', lastLap: '1:32.901', teamColor: '#3671C6', lapTimes: [93.5, 93.3, 93.1, 93.0, 92.8] },
  { position: 7, name: 'G. RUSSELL', team: 'Mercedes', gap: '+15.234', interval: '+3.111', lastLap: '1:33.056', teamColor: '#27F4D2', lapTimes: [93.7, 93.5, 93.3, 93.2, 93.0] },
  { position: 8, name: 'F. ALONSO', team: 'Aston Martin', gap: '+18.456', interval: '+3.222', lastLap: '1:33.234', teamColor: '#229971', lapTimes: [94.0, 93.8, 93.6, 93.4, 93.2] },
  { position: 9, name: 'O. PIASTRI', team: 'McLaren', gap: '+20.789', interval: '+2.333', lastLap: '1:33.401', teamColor: '#FF8000', lapTimes: [94.2, 94.0, 93.8, 93.6, 93.4] },
  { position: 10, name: 'P. GASLY', team: 'Alpine', gap: '+23.567', interval: '+2.778', lastLap: '1:33.589', teamColor: '#FF87BC', lapTimes: [94.5, 94.3, 94.1, 93.9, 93.7] },
];

// Start with empty feeds - messages will be added via voice input
const initialMessages: Message[] = [];

// Start with empty recommendations - will be generated by AI
const initialRecommendations: Recommendation[] = [];

// Generate telemetry data for one lap (100 data points)
const generateTelemetryData = (): TelemetryData[] => {
  const data: TelemetryData[] = [];
  for (let i = 0; i < 100; i++) {
    const distance = i / 100; // 0 to 1 (representing % of lap)
    data.push({
      lap: 15,
      distance: distance * 5.5, // Assuming 5.5km lap
      fuelRemaining: 85 - (distance * 2), // Fuel depletes over lap
      throttle: Math.sin(distance * Math.PI * 4) * 50 + 50, // 0-100%
      brakePressure: distance % 0.2 < 0.05 ? Math.random() * 80 + 20 : Math.random() * 10, // Braking zones
      tireTemps: {
        frontLeft: 85 + Math.sin(distance * Math.PI * 2) * 10 + Math.random() * 5,
        frontRight: 87 + Math.sin(distance * Math.PI * 2) * 10 + Math.random() * 5,
        rearLeft: 92 + Math.sin(distance * Math.PI * 2) * 8 + Math.random() * 5,
        rearRight: 90 + Math.sin(distance * Math.PI * 2) * 8 + Math.random() * 5,
      },
      brakeTemps: {
        frontLeft: 320 + (distance % 0.2 < 0.05 ? Math.random() * 180 : -Math.random() * 20),
        frontRight: 315 + (distance % 0.2 < 0.05 ? Math.random() * 180 : -Math.random() * 20),
        rearLeft: 280 + (distance % 0.2 < 0.05 ? Math.random() * 120 : -Math.random() * 15),
        rearRight: 275 + (distance % 0.2 < 0.05 ? Math.random() * 120 : -Math.random() * 15),
      },
    });
  }
  return data;
};

// Fuel consumption over laps
const mockFuelData = Array.from({ length: 25 }, (_, i) => ({
  lap: i + 1,
  fuel: 110 - (i * 3.2) - Math.random() * 2, // Starting at 110kg, consuming ~3.2kg per lap
}));

export const useRaceStore = create<RaceStore>((set) => ({
  drivers: mockDrivers,
  messages: initialMessages,
  recommendations: initialRecommendations,
  isTranscribing: false,
  currentTranscription: '',
  waveformData: Array.from({ length: 50 }, () => Math.random() * 40 + 10),
  telemetryData: generateTelemetryData(),
  fuelData: mockFuelData,
  currentLap: 1,
  
  setDrivers: (drivers) => set({ drivers }),
  
  setIsTranscribing: (value) => set({ isTranscribing: value }),
  
  setCurrentTranscription: (text) => set({ currentTranscription: text }),
  
  addMessage: (message) => {
    const newMessage: Message = {
      ...message,
      id: Date.now().toString(),
      timestamp: new Date().toLocaleTimeString('en-US', { hour12: false }),
    };
    set((state) => ({ messages: [...state.messages, newMessage] }));
  },
  
  addRecommendation: (recommendation) => {
    const newRec: Recommendation = {
      ...recommendation,
      id: Date.now().toString(),
      timestamp: new Date().toLocaleTimeString('en-US', { hour12: false }),
    };
    set((state) => ({ recommendations: [newRec, ...state.recommendations] }));
  },
  
  updateWaveform: () => {
    set({ waveformData: Array.from({ length: 50 }, () => Math.random() * 40 + 10) });
  },
  
  sendMessage: (messageId) => {
    console.log('Sending message:', messageId);
  },
  
  sendRecommendation: (recId) => {
    console.log('Sending recommendation:', recId);
  },

  updateTelemetry: (telemetry: CarlosTelemetry) => {
    console.log('ðŸ”§ updateTelemetry called:', telemetry.currentLap, 'lap', telemetry.trackMeters, 'm');
    set((state) => {
      const newDataPoint: TelemetryData = {
        lap: telemetry.currentLap,
        distance: telemetry.trackMeters / 1000, // Convert meters to km
        fuelRemaining: telemetry.fuelRemainingL,
        throttle: telemetry.throttlePct,
        brakePressure: telemetry.brakePct,
        tireTemps: {
          frontLeft: telemetry.tireTempC + (Math.random() - 0.5) * 2,
          frontRight: telemetry.tireTempC + (Math.random() - 0.5) * 2,
          rearLeft: telemetry.tireTempC + (Math.random() - 0.5) * 3,
          rearRight: telemetry.tireTempC + (Math.random() - 0.5) * 3,
        },
        brakeTemps: {
          frontLeft: telemetry.brakeTempC + (Math.random() - 0.5) * 20,
          frontRight: telemetry.brakeTempC + (Math.random() - 0.5) * 20,
          rearLeft: telemetry.brakeTempC * 0.85 + (Math.random() - 0.5) * 15,
          rearRight: telemetry.brakeTempC * 0.85 + (Math.random() - 0.5) * 15,
        },
      };

      // Keep last 100 data points for smooth graphs
      const newTelemetryData = [...state.telemetryData, newDataPoint].slice(-100);

      console.log('ðŸ“ˆ Telemetry data points:', newTelemetryData.length);

      return {
        telemetryData: newTelemetryData,
        currentLap: telemetry.currentLap,
      };
    });
  },

  updateFuelData: (lap: number, fuel: number) => {
    console.log('â›½ updateFuelData called: Lap', lap, 'Fuel:', fuel, 'L');
    set((state) => {
      const existingIndex = state.fuelData.findIndex(d => d.lap === lap);
      if (existingIndex >= 0) {
        // Update existing lap data
        const newFuelData = [...state.fuelData];
        newFuelData[existingIndex] = { lap, fuel };
        return { fuelData: newFuelData };
      } else {
        // Add new lap data
        const newFuelData = [...state.fuelData, { lap, fuel }].sort((a, b) => a.lap - b.lap);
        console.log('ðŸ“Š Fuel data points:', newFuelData.length);
        return { fuelData: newFuelData };
      }
    });
  },
}));
